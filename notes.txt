2017.08.26.
	OK so let's get to command processing finally!
	and let's do this with rotation.

	<delay> spin <x> <y> <z> <t>		// -> rotation speeds, degree; t: time to lerp there in secs

	// "Hello world:"
	repeat
	1 spin x y z t1
	1 spin p q r t2
	end

	so then:
	1.) create language definition -- done
	2.) set up actual command objects for this
		-but let's start at the other end:
			-update: advance timer
			-	if delay for next command exceeded: do that command
				- get next command if any, check delay immediately, continue until you have to
	3.) make it run

	=== problem though. So this kind of definining sh*t is very generic,
	but conversions / boxing should be avoided when executing them, really.
	So maybe the way to go is to have factory, creating commands of appropriate
	type, with appropriately typed fields


2017.08.23.

	So how should movement happen? Coordinates are given in viewport
	space (0,0) - (1,1), and get tweaked such that they don't use the full
	viewport, but instead try to scale gradually, keeping a bit closer
	to the original 9:16 reference resolution.

	So that's good, I can have a set of coordinates and ask the dude to
	go there.

	=> actually it'd be better to get the coordinates converted, for
	internal use, into world coordinates, because then we cna make easier
	comparison with current coords; and calculate e.g. deltas. But
	that's a bit beside the point.

	The point is: so I have coordinates: I have to go there. Question,
	how. Do we use DoTween?
		- actually I'm inclined to say yes, let's not
		reinvent the wheel, instead find out more about it,
		and see how we can use it to its fullest potential.
	
	=> so in this case we just launch a tween, with params supplied
	with the command, e.g:

	move (0.1, 0.635) <deltaT> <easing> <additional_params>

	

